---
title: "Custom Rules & Pattern Enforcement"
description: "Define project rules to guide the Compyle agent"
icon: "shield"
---

# Custom Rules & Pattern Enforcement

## What Are Custom Rules?

Custom rules encode your project's conventions, constraints, and best practices. They guide Compyle during research, planning, and implementation.

**Rules prevent:**
- Unwanted patterns and anti-patterns
- Inconsistent code style
- Architectural violations
- Missing required patterns

**Rules guide:**
- Naming conventions
- File organization
- Error handling patterns
- Testing requirements
- Documentation standards

## Types of Rules

<CardGroup cols={2}>
  <Card title="Naming Conventions" icon="type">
    Functions, variables, classes must follow patterns
  </Card>
  <Card title="Code Structure" icon="folder">
    File organization, import patterns
  </Card>
  <Card title="Forbidden Patterns" icon="x-circle">
    Patterns to ban or avoid
  </Card>
  <Card title="Required Patterns" icon="check-circle">
    Must-have patterns and practices
  </Card>
</CardGroup>

## Creating Rules

<Steps>
  <Step title="Go to Project Settings">
    In your project, click Settings → Custom Rules
  </Step>
  <Step title="Click 'Add Rule'">
    Start creating a new rule
  </Step>
  <Step title="Choose Rule Type">
    Select from: Naming, Structure, Forbidden, Required
  </Step>
  <Step title="Define the Pattern">
    Use regex or natural language description
  </Step>
  <Step title="Set Scope">
    Global, file pattern, or specific files
  </Step>
  <Step title="Add Description">
    Explain the rule and why it matters
  </Step>
  <Step title="Save & Activate">
    Rule applies immediately to new tasks
  </Step>
</Steps>

## Rules Configuration Interface

![Custom rules configuration screen showing rule creation and management](https://www.compyle.ai/_astro/project-rules-latest.BBt5O_Ao_2lB1N8.webp)

*Configure and manage custom rules from your project settings.*

## Rule Scopes

### Global Scope

Applies to the entire project:

```
Rule: All TypeScript files must have type annotations
Scope: Global (all *.ts files)
Pattern: No 'any' type, strict mode enabled
```

### File Pattern Scope

Applies to files matching a glob pattern:

```
Rule: React Hook Naming Convention
Scope: src/hooks/**/*.ts
Pattern: Must start with "use" (e.g., useAuth, useForm)
```

### Directory Scope

Applies to specific directory:

```
Rule: Test Files Use Jest Convention
Scope: tests/ or **/*.test.ts
Pattern: Tests must use describe/it blocks
```

## Rule Examples

### Example 1: Naming Convention

```
Name: React Hook Naming
Scope: src/hooks/**/*.tsx
Pattern: ^use[A-Z][a-zA-Z]*$
Description: All React hooks must start with lowercase "use"
Enforced: Warn (can override)

Examples:
✓ useAuth
✓ useForm
✓ useLocalStorage
✗ getAuth (wrong)
✗ authHook (wrong)
```

### Example 2: Forbidden Pattern

```
Name: No Console Logs
Scope: src/**/*.ts (except src/debug)
Pattern: console\.(log|debug)
Enforced: Block (must override to use)
Reason: Production code should use logger, not console

Compyle will:
- Block code with console.log in production files
- Ask user to use logger service instead
- Allow override with documentation
```

### Example 3: Required Documentation

```
Name: Function Documentation
Scope: src/**/*.ts
Pattern: JSDoc comment required
Enforced: Warn
Requirement: Exported functions must have JSDoc

Format:
/**
 * Brief description
 * @param {type} name - Description
 * @returns {type} Description
 */
```

### Example 4: Code Structure

```
Name: Component File Organization
Scope: src/components/**/*.tsx
Pattern: Enforce structure
Enforced: Block
Requirements:
- Component in separate file
- Styles in Component.module.css
- Tests in Component.test.tsx
- Exports default component

Compyle will enforce this structure automatically
```

## Rule Enforcement

### When Rules Are Checked

<CardGroup cols={3}>
  <Card title="Research" icon="search">
    Identify existing violations in codebase
  </Card>
  <Card title="Planning" icon="message-square">
    Consider rules in design decisions
  </Card>
  <Card title="Implementation" icon="code">
    Enforce rules in real-time during coding
  </Card>
</CardGroup>

### What Happens When Rules Are Violated

<Tip title="Rule Violation Flow">
  1. Compyle detects violation
  2. Agent explains the violation and why it matters
  3. You can:
     - Adjust approach to follow rule
     - Approve exception (with documentation)
     - Modify rule for edge case
</Tip>

### Handling Conflicts

If rules conflict:

<Accordion title="Rule Priority">
  Set precedence when rules might overlap:
  - **Critical** - Must follow always
  - **Important** - Follow unless overridden
  - **Nice to have** - Guideline, can override
</Accordion>

<Accordion title="Exceptions">
  Document exceptions when necessary:
  - Add comment explaining why exception is needed
  - Update rule if pattern needs refinement
  - Only override in specific scenarios
</Accordion>

<Accordion title="Rule Evolution">
  Rules should evolve as your project changes:
  - Review quarterly
  - Remove rules that aren't needed
  - Refine rules that cause too many violations
  - Add new rules as patterns emerge
</Accordion>

## Built-in Rule Templates

Compyle comes with templates for common patterns:

<CardGroup cols={2}>
  <Card title="TypeScript Strict Mode" icon="code">
    Type safety rules for TypeScript projects
  </Card>
  <Card title="React Best Practices" icon="react">
    Hook conventions, component patterns
  </Card>
  <Card title="Python PEP 8" icon="python">
    Python style and naming conventions
  </Card>
  <Card title="Testing Conventions" icon="test-tube">
    Test file organization and patterns
  </Card>
  <Card title="Code Documentation" icon="book">
    Comment and docstring requirements
  </Card>
  <Card title="Security Best Practices" icon="shield">
    Common security patterns to enforce
  </Card>
</CardGroup>

<Tip title="Pattern Library">
  **Looking for ready-made rule templates?** Check out our comprehensive [Pattern Library](/features/pattern-library) with 15+ copy-paste ready custom rules for TypeScript, React, APIs, testing, and more. Each pattern includes JSON configuration, code examples, and usage guidance.
</Tip>

## Rule Management

### Viewing All Rules

Go to Project Settings → Custom Rules to see:
- All active rules
- Rule scope and enforcement level
- Last modified date
- Number of violations (if any)

### Editing Rules

Click on any rule to:
- Modify pattern or scope
- Change enforcement level (warn/block)
- Update description
- Enable/disable

### Disabling Rules

Temporarily disable rules without deleting:
- Useful for experimental features
- Can re-enable anytime
- Useful during refactoring

### Rule Statistics

View statistics on rule compliance:
- Violations by rule
- Files affected
- Trends over time
- Most problematic areas

## Technical Implementation Details

### Rule Configuration Structure

Each custom rule is defined using a JSON-like configuration structure that Compyle uses to validate code:

```json
{
  "id": "typescript-naming-conventions",
  "name": "TypeScript Naming Conventions",
  "type": "naming",
  "scope": {
    "pattern": "src/**/*.{ts,tsx}",
    "exclude": ["src/**/*.d.ts", "src/test/**/*"]
  },
  "pattern": {
    "type": "regex",
    "value": "^(get|set|is|has|create|update|delete)[A-Z][a-zA-Z]*$",
    "description": "Method names should start with action verbs"
  },
  "enforcement": {
    "level": "warn",
    "priority": "important",
    "allow_override": true
  },
  "metadata": {
    "description": "Enforces consistent method naming patterns",
    "tags": ["typescript", "naming", "conventions"],
    "created_by": "team",
    "last_updated": "2024-01-15"
  }
}
```

### Rule Types & Implementation

#### 1. Naming Convention Rules

**Purpose:** Enforce consistent naming patterns across your codebase

**Implementation:**
```json
{
  "type": "naming",
  "pattern": {
    "function_regex": "^(use|get|set|handle|on)[A-Z][a-zA-Z]*$",
    "variable_regex": "^[a-z][a-zA-Z0-9]*$",
    "class_regex": "^[A-Z][a-zA-Z0-9]*$",
    "constant_regex": "^[A-Z][A-Z0-9_]*$"
  },
  "scope": "typescript_files",
  "message": "Naming convention violation: {actual} should follow {expected} pattern"
}
```

**Real-World Example:**
```typescript
// ✅ Correct naming
const userService = new UserService();
const getUserProfile = async (id: string) => {};

// ❌ Violates naming rules
const GetUserProfile = async (id: string) => {}; // Function name should start lowercase
const user_service = new UserService(); // Variable should use camelCase
```

#### 2. Structural Rules

**Purpose:** Enforce file and directory organization patterns

**Implementation:**
```json
{
  "type": "structural",
  "rules": {
    "file_organization": {
      "component_structure": [
        "import React from 'react'",
        "import { TypeScript interfaces }",
        "import { styled components }",
        "---",
        "export interface ComponentProps",
        "export const Component: React.FC<ComponentProps> = () => {",
        "  return JSX",
        "}",
        "export default Component"
      ]
    },
    "directory_patterns": {
      "components": "src/components/{Category}/{Name}.tsx",
      "hooks": "src/hooks/use{Action}.ts",
      "services": "src/services/{Service}.ts",
      "tests": "src/{path}/{Name}.test.{ext}"
    }
  }
}
```

#### 3. Forbidden Pattern Rules

**Purpose:** Prevent the use of dangerous or discouraged practices

**Implementation:**
```json
{
  "type": "forbidden",
  "patterns": [
    {
      "name": "No console.log in production",
      "regex": "console\\.(log|debug|info)",
      "severity": "block",
      "scope": "src/**/*.{ts,tsx}",
      "exceptions": ["src/debug/**/*", "*.test.{ts,tsx}"]
    },
    {
      "name": "No eval() usage",
      "regex": "eval\\(",
      "severity": "block",
      "reason": "Security risk - eval can execute arbitrary code"
    },
    {
      "name": "No any types",
      "regex": ":\\s*any\\b",
      "severity": "warn",
      "scope": "src/**/*.{ts,tsx}",
      "allow_override": true
    }
  ]
}
```

**Examples of Blocked Patterns:**
```typescript
// ❌ These will be blocked:
const userData = eval(userInput); // Security risk
console.log("Debug info"); // Production code
const handleClick = (event: any) => {}; // Use proper typing

// ✅ Alternative approaches:
const userData = JSON.parse(userInput); // Safe parsing
const logger = getLogger(); // Use proper logging
const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {}
```

#### 4. Required Pattern Rules

**Purpose:** Ensure critical patterns are always present

**Implementation:**
```json
{
  "type": "required",
  "patterns": [
    {
      "name": "Function documentation",
      "pattern": "/\\*\\*[\\s\\S]*?\\*/",
      "scope": "exported_functions",
      "severity": "warn"
    },
    {
      "name": "Error handling",
      "pattern": "try\\s*{[\\s\\S]*?catch\\s*{",
      "scope": "async_functions",
      "severity": "block"
    },
    {
      "name": "Props interface",
      "pattern": "interface\\s+\\w+Props",
      "scope": "react_components",
      "severity": "warn"
    }
  ]
}
```

### Advanced Rule Configuration

#### Conditional Rule Application

Rules can be applied based on project context:

```json
{
  "conditions": {
    "framework": "react",
    "typescript_version": ">=4.0.0",
    "testing_library": "jest"
  },
  "actions": {
    "when_matched": "apply_react_patterns",
    "when_not_matched": "skip_rule"
  }
}
```

#### Multi-File Pattern Rules

Enforce patterns across multiple files:

```json
{
  "type": "cross_file",
  "pattern": {
    "name": "Component-Handler pairing",
    "description": "Every component must have corresponding handler",
    "rule": "If {Component}.tsx exists, {Component}.handler.ts must exist",
    "scope": ["src/components/**/*.tsx", "src/handlers/**/*.ts"]
  }
}
```

### Integration with Development Tools

#### ESLint Integration

Compyle rules can extend your existing ESLint configuration:

```json
{
  "extends": ["./node_modules/@compyle/eslint-plugin-compyle/recommended"],
  "plugins": ["@compyle/compyle"],
  "rules": {
    "@compyle/compyle/naming-conventions": "error",
    "@compyle/compyle/forbidden-patterns": "error",
    "@compyle/compyle/required-patterns": "warn"
  }
}
```

#### Prettier Integration

Ensure rule compatibility with code formatting:

```json
{
  "printWidth": 80,
  "tabWidth": 2,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  "compyle": {
    "respectFormatting": true,
    "autoFormatOnSave": true
  }
}
```

#### TypeScript Configuration

Rules integrate with your tsconfig.json:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "exactOptionalPropertyTypes": true
  },
  "compyle": {
    "typeChecking": "strict",
    "reportTypeErrors": true,
    "validateImports": true
  }
}
```

### Performance Optimization

#### Rule Evaluation Optimization

For large codebases, rules are optimized using:

**1. File Change Detection**
- Only rules affecting modified files run
- Incremental evaluation reduces processing time

**2. Pattern Caching**
- Compiled regex patterns cached
- File system patterns pre-computed

**3. Parallel Rule Execution**
- Multiple rules run simultaneously
- CPU-optimized processing

**4. Smart Scope Targeting**
- Glob patterns optimized for speed
- File type filtering reduces processing

#### Performance Metrics

Track rule performance:

```json
{
  "performance": {
    "evaluation_time": "2.3ms per file",
    "cache_hit_rate": "87%",
    "parallel_rules": 12,
    "average_violations_per_file": 0.3
  }
}
```

### Team Collaboration Features

#### Rule Sharing & Versioning

**Rule Templates**
- Pre-built templates for common frameworks
- Community-contributed rule sets
- Team-specific rule collections

**Version Control Integration**
```json
{
  "git": {
    "tracked_files": "compyle-rules.json",
    "branch_strategy": "feature/rules",
    "review_required": true,
    "auto_sync": false
  }
}
```

#### Team Rule Management

**Shared Rule Set**
```json
{
  "team": {
    "name": "frontend-team",
    "rules_version": "2.1.0",
    "required_rules": ["naming", "typescript", "react"],
    "optional_rules": ["accessibility", "performance"]
  }
}
```

**Individual Overrides**
- Team leads can set organization-wide rules
- Individual developers can override in their branches
- Senior developers can approve exceptions

#### Rule Approval Workflow

For critical rules requiring team approval:

```json
{
  "approval": {
    "critical_rules": {
      "required_approvals": 2,
      "approver_roles": ["tech_lead", "senior_dev"],
      "review_period": "1 week"
    }
  }
}
```

<Tip title="Start Small">
  Define 5-10 core rules first. Add more as patterns emerge. Too many rules create friction.
</Tip>

<Tip title="Test on Existing Code">
  Run new rules against your existing codebase. Refine if they flag too many false positives.
</Tip>

<Tip title="Document Rationale">
  Explain *why* each rule exists. This helps Compyle and your team understand the intent.
</Tip>

<Tip title="Keep Rules Updated">
  Review rules quarterly. Remove rules that don't provide value. Refine rules causing excessive violations.
</Tip>

<Tip title="Communicate with Team">
  If team members don't understand the rules, violations spike. Explain and document clearly.
</Tip>

## Advanced Rule Patterns

### Regex Patterns

For complex matching, use regular expressions:

```
Pattern: ^(get|set|is|has)[A-Z][a-zA-Z]*$
Matches: getName, setColor, isActive, hasPermission
```

### Negative Patterns (Forbidden)

To forbid specific patterns:

```
Pattern: eval\(|innerHTML\s*=|dangerouslySetInnerHTML
Reason: Security risk - using dangerous APIs
```

### Structural Patterns

To enforce file/folder structure:

```
Pattern: All React components must be in src/components/
Pattern: All utilities must be in src/utils/
Pattern: All tests must be in tests/ or *.test.ts
```

## Troubleshooting

<AccordionGroup>
  <Accordion title="Rules causing too many violations">
    - Review rule definition - might be too strict
    - Check exceptions - might need allowlist for edge cases
    - Reduce scope - limit to specific directories
    - Warn instead of block - less friction
  </Accordion>
  <Accordion title="Rule isn't being enforced">
    - Check rule is enabled
    - Verify scope pattern matches your files
    - Check rule syntax (especially regex)
    - Re-enable and test with new task
  </Accordion>
  <Accordion title="Conflicting rules">
    - Set priority levels
    - Create exceptions
    - Refine scope to avoid overlap
    - Combine related rules
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={3}>
  <Card title="Pattern Library" href="./pattern-library" icon="book">
    15+ ready-made rule templates to get started
  </Card>
  <Card title="Create Your First Task" href="../getting-started/first-task" icon="lightning-bolt">
    Use rules to guide your task
  </Card>
  <Card title="Code Review Practices" href="./code-review" icon="check-circle">
    Validate rules during implementation
  </Card>
  <Card title="Best Practices Guide" href="./best-practices" icon="lightbulb">
    Learn effective Compyle usage
  </Card>
</CardGroup>
